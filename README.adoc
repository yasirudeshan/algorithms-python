# Algorithms-python
Learning Algorithms using python.

**Bubble Sort Algorithm**

Bubble Sort is a simple sorting algorithm that compares adjacent elements in a list or an array and swaps them if they are in the wrong order. This process is repeated until the entire list is sorted. Bubble Sort has a time complexity of O(n^2) and is not considered efficient for large datasets.

Here's an example of how the Bubble Sort algorithm works:

We start by comparing the first two elements of the list. If the first element is larger than the second element, we swap them.

We then compare the second and third elements of the list. If the second element is larger than the third element, we swap them.

We continue this process, comparing and swapping adjacent elements until we reach the end of the list.

Once we have reached the end of the list, we repeat the entire process again, starting from the beginning of the list, until the entire list is sorted.

Here's an example implementation of Bubble Sort in Python:

[source,python]
----
def sort(A):
    for i in range(len(A) - 1, 0, -1):
        for j in range(0, i):
            
            if A[j] > A[j + 1]:
                A[j], A[j + 1] = A[j + 1], A[j]


li = []

for i in range(8):
    li.append(int(input("Enter Number: ")))


sort(li)
print(li)
----




**Selection Sort Algorithm**

Selection Sort is a simple sorting algorithm that works by repeatedly finding the minimum element from the unsorted part of the list and swapping it with the first element of the unsorted part. This process is repeated until the entire list is sorted. Selection Sort has a time complexity of O(n^2) and is not considered efficient for large datasets.

Here's an example of how the Selection Sort algorithm works:

We start by selecting the first element of the list and assume it to be the minimum element.

We then compare the minimum element with each element in the rest of the list. If we find an element that is smaller than the minimum element, we update the minimum element to be that element.

Once we have found the minimum element in the rest of the list, we swap it with the first element of the unsorted part of the list.

We then repeat this process, selecting the next element of the unsorted part of the list and finding the minimum element in the rest of the list until the entire list is sorted.

Here's an example implementation of Selection Sort in Python:

[source,python]
----
def selection_sort(arr):
    for i in range(0, len(arr) - 1):
        min = i
        for j in range(i + 1, len(arr)):
            if(arr[j] < arr[min]):
               min  = j

        arr[i], arr[min] = arr[min], arr[i]


arr = [2, 6, 5, 1, 3, 4]

selection_sort(arr)

print(arr)

----



**Insertion sort**

Insertion Sort is a simple sorting algorithm that works by iterating through the list and inserting each element into its correct position in a sorted sublist. We start with an initially empty sorted sublist and insert each element into its correct position by comparing it to the elements in the sorted sublist and shifting any larger elements to the right. This process is repeated until the entire list is sorted. Insertion Sort has a time complexity of O(n^2) and is not considered efficient for large datasets.

Here's an example of how the Insertion Sort algorithm works:

We start by assuming that the first element of the list is already sorted.

We then iterate through the rest of the list, one element at a time, and compare each element to the elements in the sorted sublist.

If we find an element that is smaller than the last element in the sorted sublist, we shift all larger elements to the right by one position and insert the new element into its correct position.

We repeat this process, adding each new element to its correct position in the sorted sublist, until the entire list is sorted.

Here's an example implementation of Insertion Sort in Python:

[source,python]
----
def insertionSort(A):
    for i in range(1, len(A)):
        j = i
        while A[j-1] > A[j] and j > 0:
            A[j-1], A[j] = A[j], A[j-1]
            j -= 1

A = [2,7,4,1,3,8,5,9,6]
insertionSort(A)
print(A)

----




**Quick Sort**

Quick Sort is a popular sorting algorithm that uses a divide-and-conquer approach to sort a list or array of elements. It works by selecting a pivot element from the list, partitioning the list into two sub-lists based on whether each element is less than or greater than the pivot, and then recursively sorting each sub-list.

The basic steps of the Quick Sort algorithm are:

Choose a pivot element from the list. This element is often chosen as the last element in the list, but it could be any other element.

Partition the list into two sub-lists based on whether each element is less than or greater than the pivot element.

Recursively sort each sub-list by repeating steps 1 and 2 until the sub-lists are small enough to be sorted efficiently by another algorithm (e.g. insertion sort).

Combine the sorted sub-lists to produce the final sorted list.

Quick Sort has an average time complexity of O(n log n) and is often considered one of the most efficient sorting algorithms. However, its worst-case time complexity is O(n^2), which can occur when the pivot element is chosen poorly.

Here's an example implementation of the Quick Sort algorithm in Python:

[source,python]
----

def quickSort(A, left, right):
    if left < right:
        part = partition(A, left, right)
        quickSort(A, left, part - 1)
        quickSort(A, part + 1, right)

def partition(A, left, right):
    i = left
    j = right - 1
    pivot = A[right]

    while i < j:
        while i < right and A[i] < pivot:
            i += 1
        while j > left and A[j] > pivot:
            j -= 1

        if i < j:
            A[i], A[j] = A[j], A[i]

    if A[i] > pivot:
        A[i], A[right] = A[right], A[i]

    return i
            


A = [12,45,34,76,89,43,56]
quickSort(A, 0, len(A) - 1)
print(A)

----
   
